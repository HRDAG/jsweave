#!/usr/bin/env python
#
# vim: ft=python:
# -*- coding: utf-8 -*-
#
# Author: Daniel Manrique-Vallier
# Maintainer(s): Tarak Shah, Patrick Ball, Daniel Manrique-Vallier
#
# License: (c) Daniel Manrique-Vallier 2018, GPL v2 or newer
#
#
# replace occurrences of \jsonsub[xxx]{code} in TeX file with
# the content of "code" from JSON file
# In TeX file include:
#
#      \usepackage{color}
#      \newcommand{\jsonsub}[2][XXXX]{ \textcolor{red}{#1} }
#
# Use in TeX file: \jsonsub[<defaul value>][<code for substitution>]

import json
import argparse
import re

def getJson(file_name):
    with open(file_name, "r") as f:
        d = json.load(f)
    return d


def getTeX(file_name):
    with open(file_name, "r") as f_TeX:
        TeX = f_TeX.read()
    return TeX

def tex_escape(text):
    """
        https://stackoverflow.com/questions/16259923/how-can-i-escape-latex-special-characters-inside-django-templates
        :param text: a plain text message
        :return: the message escaped to appear correctly in LaTeX

        TODO: what if any conv.key is preceded by one or more backslashes?
    """
    conv = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '_': r'\_',
        '{': r'\{',
        '}': r'\}',
        '~': r'\textasciitilde{}',
        '^': r'\^{}',
        '\\': r'\textbackslash{}',
        '<': r'\textless{}',
        '>': r'\textgreater{}',
    }
    regex = re.compile(r'|'.join(re.escape(str(key))
                                 for key in
                                 sorted(conv.keys(),
                                        key=lambda item: - len(item))))
    return regex.sub(lambda match: conv[match.group()], text)


def json_re(value):
    cad = r"\\jsonsub(\[([^\]]*?)\])?\{" + re.escape(value) + r"\}"
    return re.compile(cad)


def sub(TeX, JS):
    for x, y in JS.items():
        p = json_re(x)
        TeX = p.sub(tex_escape(str(y)), TeX)
    return TeX

def check(TeX, JS):
    texlines = TeX.splitlines()
    check_results = []
    for x, y in JS.items():
        cad = r"\\jsonsub(\[([^\]]*?)\])?\{" + re.escape(x) + r"\}"
        p = re.compile(cad)
        escaped_json = tex_escape(str(y))
        diffs = [ (ln[0] + 1, p.search(ln[1]).group(2), escaped_json)
                  for ln in enumerate(texlines)
                  if p.search(ln[1]) is not None and escaped_json != p.search(ln[1]).group(2)]
        check_results.extend(diffs)
    return check_results

def check_term(TeX, JS):
    result = check(TeX, JS)
    output = ["lineno|old_value|new_value"]
    for ln in result:
        output.append(str(ln[0]) + "|" + str(ln[1]) + "|" + str(ln[2]))
    return("\n".join(output))

def update(TeX, JS):
    for x, y in JS.items():
        cad = r"\\jsonsub(\[([^\]]*?)\])?\{" + re.escape(x) + r"\}"
        replacement = r"\\jsonsub[" + tex_escape(str(y)) + "]{" + x + "}"
        p = re.compile(cad)
        TeX = p.sub(replacement, TeX)
    return TeX

def verify_substitution(TeX, JS):
    log = []
    p = re.compile(r"\\jsonsub(\[.*?\]){0,1}\{(.*?)\}")
    i = 1
    j = 1
    lns = []
    for l in TeX.splitlines():
        a = p.findall(l)
        if a:
            tmp = []
            for inst in a:
                tmp.append('\t<-->\t'.join(inst))
            log.append(i)
            lns.append("> line " + str(i) + ":\n\t\t" + '\n\t\t'.join(tmp))
            j = j + len(a)
        i = i + 1
    lns.insert(0, 'Non substituted entries: ' + str(j) + '\n')
    lns.insert(0, 'Lines with no Substitutions: ' + str(len(lns)))
    return [log, lns]


def preview_vs_code(TeX):
    'print line : code : preview'
    p = re.compile(r"\\jsonsub\[(.*?)\]{0,1}\{(.*?)\}")
    lns = []
    i = 1
    for l in TeX.splitlines():
        a = p.findall(l)
        if a:
            tmp = []
            for inst in a:
                tmp.append('{' + '<-->'.join(inst) + '}')
            lns.append("> line " + str(i) + ": " + ', '.join(tmp))
        i = i + 1
    return lns


def get_input():
    parser = argparse.ArgumentParser()
    parser.add_argument('command', choices = ['sub', 'check', 'update'])
    parser.add_argument('-t', '--tex', dest = 'tex',
                        required = True, help = 'Input TeX file')
    parser.add_argument('-j', '--json', dest = 'json',
                        required = True, help = 'JSON file')
    parser.add_argument('-l', '--log', dest = 'log', required = False,
                        help = 'Log file name')
    args = parser.parse_args()
    return(args)


def main():
    args = get_input()
    json = getJson(args.json)
    tex = getTeX(args.tex)
    cmd = args.command

    print({
        "sub": sub(tex, json),
        "check": check_term(tex, json),
        "update": update(tex, json)
    }[cmd])

    if args.log and cmd != "check":
        log = verify_substitution(tex, json)
        with open(args.log, 'w') as logfile:
            if len(log[1]) > 0:
                log[1].insert(0, 'Undefined Codes:' + str(len(log[0])))
                logfile.write('\n'.join(log[1]))
            else:
                logfile.write('Success!')
    return

if __name__ == '__main__':
    main()

# done.
