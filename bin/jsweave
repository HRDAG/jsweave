#!/usr/bin/env python
#
# vim: ft=python:
# -*- coding: utf-8 -*-
#
# Author: Daniel Manrique-Vallier
# Maintainer(s): Tarak Shah, Patrick Ball, Daniel Manrique-Vallier
#
# License: (c) Daniel Manrique-Vallier 2018, GPL v2 or newer
#
#
# replace occurrences of \jsonsub[xxx]{code} in TeX file with
# the content of "code" from JSON file
# In TeX file include:
#
#      \usepackage{color}
#      \newcommand{\jsonsub}[2][XXXX]{ \textcolor{red}{#1} }
#
# Use in TeX file: \jsonsub[<default value>]{<code for substitution>}

import json
import argparse
import re
import pylatexenc.latexencode


def get_json(file_name):
    with open(file_name, "r") as f:
        d = json.load(f)
    return d


def get_tex(file_name):
    with open(file_name, "r") as f_tex:
        tex = f_tex.read()
    return tex


def tex_escape(text):
    return pylatexenc.latexencode.utf8tolatex(str(text), brackets = False)


def jsonsub_regex(obj_name):
    pattern = r"\\jsonsub(\[([^\]]+)\])?\{" + re.escape(obj_name) + r"\}"
    return re.compile(pattern)


def sub(tex, js):
    for key, value in js.items():
        pattern = jsonsub_regex(key)
        tex = pattern.sub(tex_escape(value), tex)
    return tex


def check(tex, js):
    texlines = tex.splitlines()
    check_results = []
    for key, value in js.items():
        pattern = jsonsub_regex(key)
        data_value = tex_escape(value)
        diffs = [ (line[0] + 1, pattern.search(line[1]).group(2), data_value)
                  for line in enumerate(texlines)
                  if pattern.search(line[1]) is not None and
                     data_value != pattern.search(line[1]).group(2) ]
        check_results.extend(diffs)
    return check_results


def check_term(tex, js):
    result = check(tex, js)
    output = ["lineno|old_value|new_value"]
    for ln in result:
        output.append(str(ln[0]) + "|" + str(ln[1]) + "|" + str(ln[2]))
    return("\n".join(output))


def update(tex, js):
    for key, value in js.items():
        pattern = jsonsub_regex(key)
        replacement = r"\\jsonsub[" + tex_escape(value) + "]{" + key + "}"
        tex = pattern.sub(replacement, tex)
    return tex


def verify_substitution(tex, js):
    log = []
    p = re.compile(r"\\jsonsub(\[.*?\]){0,1}\{(.*?)\}")
    i = 1
    j = 1
    lns = []
    for l in tex.splitlines():
        a = p.findall(l)
        if a:
            tmp = []
            for inst in a:
                tmp.append('\t<-->\t'.join(inst))
            log.append(i)
            lns.append("> line " + str(i) + ":\n\t\t" + '\n\t\t'.join(tmp))
            j = j + len(a)
        i = i + 1
    lns.insert(0, 'Non substituted entries: ' + str(j) + '\n')
    lns.insert(0, 'Lines with no Substitutions: ' + str(len(lns)))
    return [log, lns]


def preview_vs_code(tex):
    'print line : code : preview'
    p = re.compile(r"\\jsonsub\[(.*?)\]{0,1}\{(.*?)\}")
    lns = []
    i = 1
    for l in tex.splitlines():
        a = p.findall(l)
        if a:
            tmp = []
            for inst in a:
                tmp.append('{' + '<-->'.join(inst) + '}')
            lns.append("> line " + str(i) + ": " + ', '.join(tmp))
        i = i + 1
    return lns


def get_input():
    parser = argparse.ArgumentParser()
    parser.add_argument('command', choices = ['sub', 'check', 'update'])
    parser.add_argument('-t', '--tex', dest = 'tex',
                        required = True, help = 'Input TeX file')
    parser.add_argument('-j', '--json', dest = 'json',
                        required = True, help = 'JSON file')
    parser.add_argument('-l', '--log', dest = 'log', required = False,
                        help = 'Log file name')
    args = parser.parse_args()
    return(args)


def main():
    args = get_input()
    json = get_json(args.json)
    tex = get_tex(args.tex)
    cmd = args.command

    print({
        "sub": sub(tex, json),
        "check": check_term(tex, json),
        "update": update(tex, json)
    }[cmd])

    if args.log and cmd != "check":
        log = verify_substitution(tex, json)
        with open(args.log, 'w') as logfile:
            if len(log[1]) > 0:
                log[1].insert(0, 'Undefined Codes:' + str(len(log[0])))
                logfile.write('\n'.join(log[1]))
            else:
                logfile.write('Success!')
    return


if __name__ == '__main__':
    main()

# done.
